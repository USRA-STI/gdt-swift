.. _bat-pha:
.. |batpha| replace:: :class:`~gdt.missions.swift.bat.pha.BatPha`
.. |TimeEnergyBins| replace:: :class:`~gdt.core.data_primitives.TimeEnergyBins`
.. |TimeBins| replace:: :class:`~gdt.core.data_primitives.TimeBins`
.. |EnergyBins| replace:: :class:`~gdt.core.data_primitives.EnergyBins`
.. |pha| replace:: :class:`~gdt.core.pha.Pha`
.. |Lightcurve| replace:: :class:`~gdt.plot.lightcurve.Lightcurve`
.. |Spectrum| replace:: :class:`~gdt.plot.spectrum.Spectrum`

**********************************************************
Swift Bat PHA Data (:mod:`gdt.missions.swift.bat.pha`)
**********************************************************
The primary science data produced by bat can be summarized as a time history of
spectra, which is provided temporally pre-binned (CTIME and CSPEC) or
temporally unbinned (TTE). These data types are produced as "snippets" for
every single trigger and are also provided continuously. CTIME and CSPEC are
provided in daily chunks, and TTE are provided in hourly chunks (since late
2012). One of the most common things that a user of bat data wants to do is
look at this data (what we call a lightcurve) for one or more detectors over
some energy range.

The CTIME and CSPEC data are temporally pre-binned data, which have 8 and 128
energy channels respectively. These data files can be read by the |batpha|
class (or the aliased |Ctime| and |Cspec| classes).

    >>> from gdt.core import data_path
    >>> from gdt.missions.swift.bat.pha import BatPha
    >>> # read a pha file
    >>> filepath = data_path.joinpath('swift-bat/sw00974827000bevas.pha')
    >>> file = batpha.open(filepath)
    >>> file
    <BatPha: sw00974827000bevas.pha;
    trigger time: 612354468.864;
    time range (69.73658001422882, 113.2039999961853);
    energy range (0.0, 6553.6)>

Since bat uses the FITS format, the data files have multiple data extensions,
each with metadata information in a header. There is also a primary header that
contains metadata relevant to the overall file. You can access this metadata
information:

    >>> file.headers.keys()
    ['PRIMARY', 'SPECTRUM', 'EBOUNDS', 'STDGTI']

    >>> file.headers['PRIMARY']
    TELESCOP= 'SWIFT   '           / Telescope (mission) name
    INSTRUME= 'BAT     '           /  Instrument name
    OBS_ID  = '00974827000'        / Observation ID
    TARG_ID =               974827 / Target ID
    SEG_NUM =                    0 / Segment number
    TIMESYS = 'TT      '           / time system
    MJDREFI =                51910 / MJD reference day Jan 2001 00:00:00
    MJDREFF = '0.00074287037'      / MJD reference (fraction of day) 01 Jan 2001 00:
    CLOCKAPP= 'False   '           / If clock correction are applied (F/T)
    TIMEUNIT= 's       '           / Time unit for timing header keywords
    TSTART  =      612354538.60058 / As in the TIME column
    TSTOP   =        612354582.068 / As in the TIME column
    DATE-OBS= '2020-05-28T10:28:53'
    DATE-END= '2020-05-28T10:29:37'
    ORIGIN  = 'NASA/GSFC'          / file creation location
    CREATOR = 'extractor v5.24'    / file creator
    TLM2FITS= 'V7.21   '           / Telemetry converter version number
    DATE    = '2020-06-07T06:39:30' / file creation date (YYYY-MM-DDThh:mm:ss UT)
    NEVENTS =              1754792 / Number of events
    DATAMODE= 'Event   '           / Datamode
    OBJECT  = 'GRB200528a'         / Object name
    MJD-OBS =    58997.43753222893 / MJD of data start time
    TIMEREF = 'LOCAL   '           / reference time
    EQUINOX =               2000.0 / Equinox for pointing RA/Dec
    RADECSYS= 'FK5     '           / Coordinates System
    USER    = 'apsop   '           / User name of creator
    FILIN001= 'sw00974827000bevshsp_uf.evt' / Input file name
    TIMEZERO=                  0.0 / Time Zero
    CHECKSUM= '5F5HAE5F6E5FAE5F'   / HDU checksum updated 2020-06-07T06:49:01
    DATASUM = '         0'         / data unit checksum updated 2020-06-07T06:32:34
    PROCVER = '3.18.11 '           / Processing script version
    SOFTVER = 'Hea_27Jul2015_V6.17_Swift_Rel4.5(Bld34)_27Jul2015_SDCpatch_16'
    CALDBVER= 'b20171016_u20170922_x20190910_m20200504' / CALDB index versions used
    SEQPNUM =                    6 / Number of times the dataset processed
    RA_OBJ  =             176.6439 / [deg] R.A. Object
    DEC_OBJ =             58.19214 / [dec] Dec Object
    RA_PNT  =     176.681859056405 / [deg] RA pointing
    DEC_PNT =     58.1445301944316 / [deg] Dec pointing
    PA_PNT  =     298.735423901845 / [deg] Position angle (roll)
    TRIGTIME=        612354468.864 / MET TRIGger Time for Automatic Target
    CATSRC  = 'False   '
    ATTFLAG =                  110 / Attitude origin: 100=sat/spacecraft
    UTCFINIT=            -25.01712 / [s] UTCF at TSTART


There is easy access for certain important properties of the data:

    >>> # the good time intervals for the data
    >>> file.gti
    <Gti: 1 intervals; range (69.73658001422882, 113.2039999961853)>

    >>> # the trigger time
    >>> file.trigtime
    612354468.864

    >>> # the time range
    >>> file.time_range
    (69.73658001422882, 113.2039999961853)

    >>> # the energy range
    >>> file.energy_range
    (0.0, 6553.6)

    >>> # number of energy channels
    >>> file.num_chans
    80

We can retrieve the time history spectra data contained within the file, which
is a |TimeEnergyBins| class (see
:external:ref:`2D Binned Data<core-data_primitives-2d>` for more details).

    >>> file.data
    <EnergyBins: 80 bins;
    range (0.0, 6553.6);
    1 contiguous segments>

Through the |pha| base class, there are a lot of high level functions
available to us, such as slicing the data in time or energy:


    >>> energy_sliced = file.slice_energy((50.0, 500.0))
    >>> energy_sliced
    <BatPha:
    trigger time: 612354468.864;
    time range (69.73658001422882, 113.2039999961853);
    energy range (48.9, 6553.6)>


As mentioned, this data is 2-dimensional, so what do we do if we want a
lightcurve covering a particular energy range? We integrate (sum) over energy,
and we can easily do this:

    >>> lightcurve = file.to_lightcurve(energy_range=(50.0, 500.0))
    >>> lightcurve
    <TimeBins: 14433 bins;
     range (-899.3424419760704, 1000.8578699827194);
     1 contiguous segments>

Similarly, we can integrate over time to produce a count spectrum:

    >>> spectrum = file.to_spectrum(time_range=(-10.0, 10.0))
    >>> spectrum
    <EnergyBins: 8 bins;
     range (4.323754, 2000.0);
     1 contiguous segments>

The resulting objects are |TimeBins| and |EnergyBins|, respectively, and see
:external:ref:`1D Binned Data<core-data_primitives-1d>` for more details on how
to use them.

Of course, once we have produced a lightcurve or spectrum data object, often
we want to plot it.  For that, we use the |Lightcurve| and |Spectrum| plotting
classes:

    >>> import matplotlib.pyplot as plt
    >>> from gdt.core.plot.lightcurve import Lightcurve
    >>> lcplot = Lightcurve(data=lightcurve)
    >>> plt.show()

.. image:: pha_figs/phafig1.png

This plot may look odd without context. Since we are reading a trigger CTIME
file, the file contains multiple time resolutions. Normally the CTIME data is
accumulated in 256 ms duration bins, but starting at trigger time, the data
switches to 64 ms duration bins for several hundred seconds, and then it goes
back to 256 ms bins.

So maybe the native CTIME resolution is overkill because it's hard to see the
signal. We can make it easier to see the signal if we bin it up (see
:external:ref:`The Binning Package<binning>` for details):

    >>> from bat.binning.binned import rebin_by_time
    >>> # rebin the data to 2.048 s resolution
    >>> rebinned_ctime = ctime.rebin_time(rebin_by_time, 2.048)
    >>> lcplot = Lightcurve(data=rebinned_ctime.to_lightcurve())
    >>> # zoom in
    >>> lcplot.xlim = (-250.0, 250.0)
    >>> lcplot.ylim = (1000.0, 1500.0)

After rebinning the data and zooming in a little, we can now easily see the
GRB signal in the lightcurve.

.. image:: pha_figs/phafig2.png

Similarly, we can plot the count spectrum:

    >>> from gdt.plot.spectrum import Spectrum
    >>> specplot = Spectrum(data=spectrum)
    >>> plt.show()

.. image:: pha_figs/phafig3.png

See :external:ref:`Plotting Lightcurves<plot-lightcurve>` and
:external:ref:`Plotting Count Spectra<plot-spectrum>` for more on
how to modify these plots.

Finally, we can write out a new fully-qualified pha FITS file after some
reduction tasks.  For example, we can write out our time-sliced data object:

    >>> time_sliced_file.write('./', filename='my_first_custom_ctime.pha')

For more details about working with pha data, see
:external:ref:`pha Files<core-pha>`.

Reference/API
=============

.. automodapi:: gdt.missions.swift.bat.pha
   :inherited-members:
